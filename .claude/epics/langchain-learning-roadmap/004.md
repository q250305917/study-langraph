---
name: 交互式学习环境：配置Jupyter，创建练习Notebook
status: open
created: 2025-09-21T02:48:13Z
updated: 2025-09-21T02:48:13Z
github: [Will be updated when synced to GitHub]
depends_on: [002]
parallel: true
conflicts_with: []
---

## 描述

构建一个完整的交互式学习环境，包括配置优化的Jupyter环境、创建结构化的练习Notebook以及建立学习进度追踪系统。这个环境将为学习者提供直观、互动的LangChain学习体验，支持实时代码执行、可视化结果展示和进度管理。

## 验收标准

- [ ] 配置并优化Jupyter Lab环境
- [ ] 创建交互式LangChain学习Notebook系列
- [ ] 实现学习进度追踪系统
- [ ] 建立可视化展示组件
- [ ] 创建练习题库和解答系统
- [ ] 实现代码片段管理器
- [ ] 配置自动保存和版本控制
- [ ] 创建环境快速启动脚本
- [ ] 提供学习路径导航
- [ ] 建立错误诊断和帮助系统

## 技术细节

### Jupyter环境结构
```
jupyter_env/
├── notebooks/
│   ├── 01_基础概念/
│   │   ├── 01_langchain_introduction.ipynb    # LangChain简介
│   │   ├── 02_llm_basics.ipynb               # LLM基础
│   │   ├── 03_prompts_templates.ipynb        # 提示词和模板
│   │   └── exercises/                        # 练习题
│   ├── 02_核心组件/
│   │   ├── 01_chains_introduction.ipynb      # 链的介绍
│   │   ├── 02_agents_basics.ipynb           # 代理基础
│   │   ├── 03_memory_systems.ipynb          # 记忆系统
│   │   └── exercises/
│   ├── 03_高级应用/
│   │   ├── 01_rag_systems.ipynb             # RAG系统
│   │   ├── 02_multi_agent.ipynb             # 多代理系统
│   │   ├── 03_evaluation.ipynb              # 评估系统
│   │   └── exercises/
│   ├── 04_实战项目/
│   │   ├── 01_chatbot_project.ipynb         # 聊天机器人项目
│   │   ├── 02_qa_system.ipynb               # 问答系统项目
│   │   ├── 03_document_analysis.ipynb       # 文档分析项目
│   │   └── projects/
│   └── utils/
│       ├── progress_tracker.ipynb           # 进度追踪器
│       ├── code_snippets.ipynb              # 代码片段库
│       └── troubleshooting.ipynb            # 故障排除
├── extensions/
│   ├── langchain_extension/                 # 自定义LangChain扩展
│   ├── progress_tracker/                    # 进度追踪扩展
│   └── code_helper/                         # 代码助手扩展
├── configs/
│   ├── jupyter_notebook_config.py          # Jupyter配置
│   ├── lab_settings.json                   # JupyterLab设置
│   └── extensions_config.json              # 扩展配置
├── styles/
│   ├── custom.css                          # 自定义样式
│   └── themes/                             # 主题文件
└── scripts/
    ├── setup_env.py                        # 环境设置脚本
    ├── install_extensions.sh               # 扩展安装脚本
    └── start_jupyter.py                    # 启动脚本
```

### 核心Notebook示例

#### LangChain基础介绍Notebook
```python
# notebooks/01_基础概念/01_langchain_introduction.ipynb
{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "tags": ["学习目标"]
   },
   "source": [
    "# LangChain 基础介绍\n",
    "\n",
    "## 学习目标\n",
    "- 理解LangChain的核心概念和架构\n",
    "- 掌握LangChain的基本使用方法\n",
    "- 了解LangChain与其他AI框架的区别\n",
    "\n",
    "## 预计学习时间: 30分钟\n",
    "## 难度级别: ⭐⭐☆☆☆"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": ["环境检查"]
   },
   "outputs": [],
   "source": [
    "# 环境检查和依赖导入\n",
    "import sys\n",
    "import os\n",
    "from IPython.display import display, HTML, Markdown\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "# 检查LangChain安装\n",
    "try:\n",
    "    import langchain\n",
    "    print(f\"✅ LangChain版本: {langchain.__version__}\")\n",
    "except ImportError:\n",
    "    print(\"❌ LangChain未安装，请运行: pip install langchain\")\n",
    "    \n",
    "# 加载进度追踪器\n",
    "from utils.progress_tracker import ProgressTracker\n",
    "tracker = ProgressTracker(\"01_langchain_introduction\")\n",
    "tracker.start_lesson()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. 什么是LangChain？\n",
    "\n",
    "LangChain是一个用于构建基于大语言模型(LLM)应用程序的框架。它提供了一套工具和抽象，使开发者能够：\n",
    "\n",
    "- 🔗 **组合不同组件**: 将LLM、提示词、工具等组合成复杂的应用\n",
    "- 🧠 **管理记忆**: 为AI应用添加上下文记忆能力\n",
    "- 🔧 **集成工具**: 让AI能够调用外部工具和API\n",
    "- 📊 **处理数据**: 加载、处理和检索各种数据源"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": ["互动演示"]
   },
   "outputs": [],
   "source": [
    "# 第一个LangChain示例\n",
    "from langchain_openai import ChatOpenAI\n",
    "from langchain_core.messages import HumanMessage\n",
    "\n",
    "# 注意：需要设置OPENAI_API_KEY环境变量\n",
    "# 或者在这里直接设置（不推荐在生产环境中这样做）\n",
    "\n",
    "def create_simple_llm_demo():\n",
    "    \"\"\"创建一个简单的LLM演示\"\"\"\n",
    "    \n",
    "    # 检查API密钥\n",
    "    api_key = os.getenv('OPENAI_API_KEY')\n",
    "    if not api_key:\n",
    "        return \"⚠️ 请设置OPENAI_API_KEY环境变量\"\n",
    "    \n",
    "    # 初始化LLM\n",
    "    llm = ChatOpenAI(\n",
    "        model=\"gpt-3.5-turbo\",\n",
    "        temperature=0.7,\n",
    "        max_tokens=100\n",
    "    )\n",
    "    \n",
    "    # 创建消息\n",
    "    message = HumanMessage(content=\"用一句话解释什么是人工智能\")\n",
    "    \n",
    "    # 获取回应\n",
    "    response = llm.invoke([message])\n",
    "    \n",
    "    return response.content\n",
    "\n",
    "# 运行演示\n",
    "demo_result = create_simple_llm_demo()\n",
    "print(f\"🤖 AI回答: {demo_result}\")\n",
    "\n",
    "# 记录完成状态\n",
    "tracker.complete_section(\"basic_demo\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. LangChain核心组件\n",
    "\n",
    "### 2.1 LLMs（大语言模型）\n",
    "LangChain支持多种LLM提供商，包括OpenAI、Anthropic、本地模型等。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": ["组件演示"]
   },
   "outputs": [],
   "source": [
    "# LLM组件演示\n",
    "from langchain.schema import AIMessage, HumanMessage, SystemMessage\n",
    "\n",
    "def demonstrate_llm_types():\n",
    "    \"\"\"演示不同类型的LLM使用\"\"\"\n",
    "    \n",
    "    results = {}\n",
    "    \n",
    "    # 1. 聊天模型示例\n",
    "    if os.getenv('OPENAI_API_KEY'):\n",
    "        chat_model = ChatOpenAI(model=\"gpt-3.5-turbo\")\n",
    "        \n",
    "        messages = [\n",
    "            SystemMessage(content=\"你是一个有用的AI助手，擅长解释技术概念。\"),\n",
    "            HumanMessage(content=\"请用简单的语言解释什么是API\")\n",
    "        ]\n",
    "        \n",
    "        response = chat_model.invoke(messages)\n",
    "        results['chat_model'] = response.content\n",
    "    else:\n",
    "        results['chat_model'] = \"需要OPENAI_API_KEY来运行此示例\"\n",
    "    \n",
    "    return results\n",
    "\n",
    "# 运行演示\n",
    "llm_demo = demonstrate_llm_types()\n",
    "\n",
    "for model_type, result in llm_demo.items():\n",
    "    print(f\"\\n{model_type.upper()}:\")\n",
    "    print(f\"📝 {result}\")\n",
    "\n",
    "tracker.complete_section(\"llm_components\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 2.2 提示词模板(Prompt Templates)\n",
    "提示词模板允许你创建可复用的、参数化的提示词。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": ["模板演示"]
   },
   "outputs": [],
   "source": [
    "# 提示词模板演示\n",
    "from langchain_core.prompts import PromptTemplate, ChatPromptTemplate\n",
    "\n",
    "def demonstrate_prompt_templates():\n",
    "    \"\"\"演示提示词模板的使用\"\"\"\n",
    "    \n",
    "    # 1. 基础提示词模板\n",
    "    basic_template = PromptTemplate(\n",
    "        input_variables=[\"topic\", \"level\"],\n",
    "        template=\"请为{level}水平的学习者解释{topic}这个概念。\"\n",
    "    )\n",
    "    \n",
    "    basic_prompt = basic_template.format(\n",
    "        topic=\"机器学习\",\n",
    "        level=\"初学者\"\n",
    "    )\n",
    "    \n",
    "    # 2. 聊天提示词模板\n",
    "    chat_template = ChatPromptTemplate.from_messages([\n",
    "        (\"system\", \"你是一个专业的{subject}老师。\"),\n",
    "        (\"human\", \"请解释{concept}，并给出一个实际应用的例子。\")\n",
    "    ])\n",
    "    \n",
    "    chat_prompt = chat_template.format_messages(\n",
    "        subject=\"数据科学\",\n",
    "        concept=\"数据清洗\"\n",
    "    )\n",
    "    \n",
    "    return {\n",
    "        \"basic_prompt\": basic_prompt,\n",
    "        \"chat_prompt\": [msg.content for msg in chat_prompt]\n",
    "    }\n",
    "\n",
    "# 运行演示\n",
    "prompt_demo = demonstrate_prompt_templates()\n",
    "\n",
    "print(\"🎯 基础提示词模板结果:\")\n",
    "print(prompt_demo[\"basic_prompt\"])\n",
    "\n",
    "print(\"\\n💬 聊天提示词模板结果:\")\n",
    "for i, content in enumerate(prompt_demo[\"chat_prompt\"]):\n",
    "    print(f\"  {i+1}. {content}\")\n",
    "\n",
    "tracker.complete_section(\"prompt_templates\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 💪 练习时间\n",
    "\n",
    "现在轮到你来实践了！完成以下练习来巩固你的学习。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": ["练习"]
   },
   "outputs": [],
   "source": [
    "# 练习1: 创建你自己的提示词模板\n",
    "# 任务: 创建一个用于生成学习计划的提示词模板\n",
    "\n",
    "def exercise_1():\n",
    "    \"\"\"练习: 创建学习计划提示词模板\"\"\"\n",
    "    \n",
    "    # TODO: 创建一个提示词模板，包含以下变量:\n",
    "    # - subject: 学习主题\n",
    "    # - duration: 学习时长\n",
    "    # - level: 学习水平\n",
    "    \n",
    "    # 你的代码在这里\n",
    "    template = PromptTemplate(\n",
    "        input_variables=[\"subject\", \"duration\", \"level\"],\n",
    "        template=\"请为{level}水平的学习者创建一个{duration}的{subject}学习计划。包括每天的学习内容和目标。\"\n",
    "    )\n",
    "    \n",
    "    # 测试你的模板\n",
    "    test_prompt = template.format(\n",
    "        subject=\"Python编程\",\n",
    "        duration=\"30天\",\n",
    "        level=\"初学者\"\n",
    "    )\n",
    "    \n",
    "    return test_prompt\n",
    "\n",
    "# 运行练习\n",
    "exercise_result = exercise_1()\n",
    "print(\"🎯 你的学习计划提示词:\")\n",
    "print(exercise_result)\n",
    "\n",
    "# 自动评估\n",
    "if \"subject\" in exercise_result and \"duration\" in exercise_result:\n",
    "    print(\"\\n❌ 提示: 确保变量被正确替换了\")\n",
    "elif \"Python编程\" in exercise_result and \"30天\" in exercise_result:\n",
    "    print(\"\\n✅ 练习完成正确！\")\n",
    "    tracker.complete_exercise(\"exercise_1\")\n",
    "else:\n",
    "    print(\"\\n⚠️ 请检查你的模板格式\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 📊 学习进度\n",
    "\n",
    "查看你的学习进度和统计信息。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": ["进度追踪"]
   },
   "outputs": [],
   "source": [
    "# 显示学习进度\n",
    "progress = tracker.get_progress()\n",
    "\n",
    "print(\"📈 学习进度报告\")\n",
    "print(\"=\" * 30)\n",
    "print(f\"📚 课程: {progress['lesson_name']}\")\n",
    "print(f\"⏱️ 学习时长: {progress['duration']} 分钟\")\n",
    "print(f\"✅ 完成部分: {progress['completed_sections']}/{progress['total_sections']}\")\n",
    "print(f\"💪 完成练习: {progress['completed_exercises']}/{progress['total_exercises']}\")\n",
    "print(f\"🎯 完成率: {progress['completion_rate']:.1%}\")\n",
    "\n",
    "# 可视化进度\n",
    "from IPython.display import HTML\n",
    "\n",
    "progress_bar = f\"\"\"\n",
    "<div style=\"background-color: #f0f0f0; border-radius: 10px; padding: 3px;\">\n",
    "    <div style=\"background-color: #4CAF50; width: {progress['completion_rate']*100:.1f}%; \n",
    "                height: 20px; border-radius: 7px; text-align: center; color: white; \n",
    "                line-height: 20px; font-size: 12px;\">\n",
    "        {progress['completion_rate']:.1%}\n",
    "    </div>\n",
    "</div>\n",
    "\"\"\"\n",
    "\n",
    "display(HTML(progress_bar))\n",
    "\n",
    "# 完成课程\n",
    "if progress['completion_rate'] >= 0.8:\n",
    "    tracker.complete_lesson()\n",
    "    print(\"\\n🎉 恭喜完成本课程！\")\n",
    "    print(\"📝 建议: 继续学习下一课程 '02_llm_basics.ipynb'\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.0"
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": false,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": false,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": false
  }
 }
}
```

### 进度追踪系统
```python
# utils/progress_tracker.py
import json
import os
from datetime import datetime, timedelta
from typing import Dict, List, Any
import matplotlib.pyplot as plt
import seaborn as sns
from IPython.display import display, HTML

class ProgressTracker:
    """学习进度追踪器"""
    
    def __init__(self, lesson_name: str, data_dir: str = "progress_data"):
        self.lesson_name = lesson_name
        self.data_dir = data_dir
        self.data_file = os.path.join(data_dir, f"{lesson_name}_progress.json")
        self.start_time = None
        self.progress_data = self._load_progress()
        
        # 确保数据目录存在
        os.makedirs(data_dir, exist_ok=True)
    
    def _load_progress(self) -> Dict[str, Any]:
        """加载进度数据"""
        if os.path.exists(self.data_file):
            with open(self.data_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {
            "lesson_name": self.lesson_name,
            "start_time": None,
            "end_time": None,
            "completed_sections": [],
            "completed_exercises": [],
            "total_sections": 4,  # 可配置
            "total_exercises": 3,  # 可配置
            "study_sessions": []
        }
    
    def _save_progress(self):
        """保存进度数据"""
        with open(self.data_file, 'w', encoding='utf-8') as f:
            json.dump(self.progress_data, f, ensure_ascii=False, indent=2)
    
    def start_lesson(self):
        """开始课程学习"""
        self.start_time = datetime.now()
        if not self.progress_data.get("start_time"):
            self.progress_data["start_time"] = self.start_time.isoformat()
        
        self.progress_data["study_sessions"].append({
            "start_time": self.start_time.isoformat(),
            "end_time": None
        })
        
        self._save_progress()
        print(f"🚀 开始学习: {self.lesson_name}")
    
    def complete_section(self, section_name: str):
        """完成章节"""
        if section_name not in self.progress_data["completed_sections"]:
            self.progress_data["completed_sections"].append(section_name)
            self._save_progress()
            print(f"✅ 完成章节: {section_name}")
    
    def complete_exercise(self, exercise_name: str):
        """完成练习"""
        if exercise_name not in self.progress_data["completed_exercises"]:
            self.progress_data["completed_exercises"].append(exercise_name)
            self._save_progress()
            print(f"💪 完成练习: {exercise_name}")
    
    def complete_lesson(self):
        """完成整个课程"""
        end_time = datetime.now()
        self.progress_data["end_time"] = end_time.isoformat()
        
        # 更新当前学习会话
        if self.progress_data["study_sessions"]:
            self.progress_data["study_sessions"][-1]["end_time"] = end_time.isoformat()
        
        self._save_progress()
        print(f"🎉 完成课程: {self.lesson_name}")
    
    def get_progress(self) -> Dict[str, Any]:
        """获取进度统计"""
        completed_sections = len(self.progress_data["completed_sections"])
        total_sections = self.progress_data["total_sections"]
        completed_exercises = len(self.progress_data["completed_exercises"])
        total_exercises = self.progress_data["total_exercises"]
        
        completion_rate = (completed_sections + completed_exercises) / (total_sections + total_exercises)
        
        # 计算学习时长
        duration = 0
        if self.start_time:
            current_time = datetime.now()
            duration = (current_time - self.start_time).total_seconds() / 60  # 分钟
        
        return {
            "lesson_name": self.lesson_name,
            "completed_sections": completed_sections,
            "total_sections": total_sections,
            "completed_exercises": completed_exercises,
            "total_exercises": total_exercises,
            "completion_rate": completion_rate,
            "duration": duration
        }
    
    def visualize_progress(self):
        """可视化学习进度"""
        progress = self.get_progress()
        
        # 创建进度图表
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))
        
        # 完成率饼图
        completed = progress["completed_sections"] + progress["completed_exercises"]
        total = progress["total_sections"] + progress["total_exercises"]
        remaining = total - completed
        
        ax1.pie([completed, remaining], 
                labels=['已完成', '待完成'],
                colors=['#4CAF50', '#f0f0f0'],
                autopct='%1.1f%%',
                startangle=90)
        ax1.set_title('总体完成率')
        
        # 分类进度条形图
        categories = ['章节', '练习']
        completed_counts = [progress["completed_sections"], progress["completed_exercises"]]
        total_counts = [progress["total_sections"], progress["total_exercises"]]
        
        x_pos = range(len(categories))
        ax2.bar(x_pos, completed_counts, color='#4CAF50', label='已完成')
        ax2.bar(x_pos, [t-c for t, c in zip(total_counts, completed_counts)], 
                bottom=completed_counts, color='#f0f0f0', label='待完成')
        
        ax2.set_xlabel('类别')
        ax2.set_ylabel('数量')
        ax2.set_title('分类完成情况')
        ax2.set_xticks(x_pos)
        ax2.set_xticklabels(categories)
        ax2.legend()
        
        plt.tight_layout()
        plt.show()

class NotebookHelper:
    """Notebook辅助工具类"""
    
    @staticmethod
    def create_learning_objectives(objectives: List[str]) -> str:
        """创建学习目标显示"""
        html = "<div style='background-color: #e3f2fd; padding: 15px; border-radius: 5px; margin: 10px 0;'>"
        html += "<h3 style='margin-top: 0; color: #1976d2;'>🎯 学习目标</h3>"
        html += "<ul>"
        for obj in objectives:
            html += f"<li style='margin: 5px 0;'>{obj}</li>"
        html += "</ul></div>"
        return html
    
    @staticmethod
    def create_code_explanation(code: str, explanation: str) -> str:
        """创建代码解释框"""
        html = f"""
        <div style='border: 1px solid #ddd; border-radius: 5px; margin: 10px 0;'>
            <div style='background-color: #f8f9fa; padding: 10px; border-bottom: 1px solid #ddd;'>
                <strong>💡 代码解释</strong>
            </div>
            <div style='padding: 15px;'>
                <pre style='background-color: #f8f9fa; padding: 10px; border-radius: 3px;'><code>{code}</code></pre>
                <p style='margin-top: 10px;'>{explanation}</p>
            </div>
        </div>
        """
        return html
    
    @staticmethod
    def create_exercise_box(title: str, description: str, difficulty: str = "中等") -> str:
        """创建练习题框"""
        difficulty_colors = {
            "简单": "#4CAF50",
            "中等": "#FF9800", 
            "困难": "#F44336"
        }
        color = difficulty_colors.get(difficulty, "#FF9800")
        
        html = f"""
        <div style='border: 2px solid {color}; border-radius: 8px; margin: 15px 0; padding: 0;'>
            <div style='background-color: {color}; color: white; padding: 10px; margin: 0;'>
                <h4 style='margin: 0;'>💪 {title}</h4>
                <small>难度: {difficulty}</small>
            </div>
            <div style='padding: 15px; background-color: #fafafa;'>
                {description}
            </div>
        </div>
        """
        return html
```

### 环境配置脚本
```python
# scripts/setup_env.py
#!/usr/bin/env python3
"""
Jupyter学习环境安装和配置脚本
"""

import os
import sys
import subprocess
import json
from pathlib import Path

def install_packages():
    """安装必要的Python包"""
    packages = [
        "jupyter",
        "jupyterlab", 
        "notebook",
        "langchain",
        "langchain-openai",
        "langchain-community", 
        "python-dotenv",
        "matplotlib",
        "seaborn",
        "pandas",
        "numpy",
        "ipywidgets",
        "tqdm"
    ]
    
    print("📦 安装Python包...")
    for package in packages:
        try:
            subprocess.run([sys.executable, "-m", "pip", "install", package], 
                         check=True, capture_output=True)
            print(f"✅ {package} 安装成功")
        except subprocess.CalledProcessError as e:
            print(f"❌ {package} 安装失败: {e}")

def install_jupyter_extensions():
    """安装Jupyter扩展"""
    extensions = [
        "jupyterlab-toc",           # 目录
        "jupyterlab-git",           # Git集成
        "jupyterlab_code_formatter", # 代码格式化
        "@jupyter-widgets/jupyterlab-manager"  # 组件管理
    ]
    
    print("🔧 安装JupyterLab扩展...")
    for extension in extensions:
        try:
            subprocess.run(["jupyter", "labextension", "install", extension], 
                         check=True, capture_output=True)
            print(f"✅ {extension} 安装成功")
        except subprocess.CalledProcessError as e:
            print(f"❌ {extension} 安装失败: {e}")

def setup_jupyter_config():
    """配置Jupyter"""
    # 创建配置目录
    config_dir = Path.home() / ".jupyter"
    config_dir.mkdir(exist_ok=True)
    
    # Jupyter Notebook配置
    notebook_config = """
# 自动保存配置
c.FileContentsManager.checkpoints_kwargs = {'keep_all': True}
c.NotebookApp.autosave_interval = 30  # 30秒自动保存

# 允许所有IP访问
c.NotebookApp.ip = '0.0.0.0'
c.NotebookApp.allow_origin = '*'
c.NotebookApp.disable_check_xsrf = True

# 显示行号
c.CodeCell.cm_config = {'lineNumbers': True}

# 扩展配置
c.NotebookApp.nbserver_extensions = {
    'jupyter_nbextensions_configurator': True,
}
"""
    
    config_file = config_dir / "jupyter_notebook_config.py"
    with open(config_file, 'w', encoding='utf-8') as f:
        f.write(notebook_config)
    
    print(f"✅ Jupyter配置文件创建: {config_file}")

def create_startup_script():
    """创建启动脚本"""
    script_content = """#!/usr/bin/env python3
import os
import sys
import subprocess
from pathlib import Path

def start_jupyter():
    # 设置工作目录
    notebook_dir = Path(__file__).parent / "notebooks"
    notebook_dir.mkdir(exist_ok=True)
    
    # 设置环境变量
    env = os.environ.copy()
    env['JUPYTER_CONFIG_DIR'] = str(Path.home() / ".jupyter")
    
    # 启动JupyterLab
    try:
        subprocess.run([
            sys.executable, "-m", "jupyter", "lab",
            "--notebook-dir", str(notebook_dir),
            "--no-browser",
            "--ip", "0.0.0.0",
            "--port", "8888"
        ], env=env)
    except KeyboardInterrupt:
        print("\\n👋 Jupyter已停止")

if __name__ == "__main__":
    print("🚀 启动Jupyter学习环境...")
    start_jupyter()
"""
    
    script_file = Path("start_jupyter.py")
    with open(script_file, 'w', encoding='utf-8') as f:
        f.write(script_content)
    
    # 添加执行权限
    os.chmod(script_file, 0o755)
    
    print(f"✅ 启动脚本创建: {script_file}")

def main():
    """主函数"""
    print("🔧 开始配置Jupyter学习环境...")
    
    # 安装包
    install_packages()
    
    # 配置Jupyter
    setup_jupyter_config()
    
    # 创建启动脚本
    create_startup_script()
    
    print("\\n🎉 Jupyter学习环境配置完成！")
    print("\\n使用方法:")
    print("1. 运行: python start_jupyter.py")
    print("2. 在浏览器中打开显示的URL")
    print("3. 开始你的LangChain学习之旅！")

if __name__ == "__main__":
    main()
```

## 实现步骤

1. **环境基础配置**
   - 安装和配置Jupyter Lab
   - 安装必要的扩展和插件
   - 创建自定义配置文件

2. **Notebook内容开发**
   - 创建结构化的学习Notebook
   - 实现交互式代码示例
   - 添加练习题和解答系统

3. **进度追踪系统**
   - 开发进度追踪器类
   - 实现学习统计和可视化
   - 创建成就系统

4. **辅助工具开发**
   - 代码片段管理器
   - 错误诊断工具
   - 学习路径导航

5. **测试和优化**
   - 测试所有Notebook功能
   - 优化性能和用户体验
   - 创建使用文档

## 成功指标

- Jupyter环境稳定运行，支持所有LangChain功能
- 学习Notebook内容完整，覆盖所有知识点
- 进度追踪系统准确记录学习状态
- 练习题系统有效帮助技能提升
- 用户体验流畅，界面友好

## 依赖项

- 依赖任务002（核心框架）提供的项目结构
- Python环境和虚拟环境配置
- Jupyter相关包和扩展
- LangChain及其依赖包

## 风险与缓解

**风险**: Jupyter环境配置复杂，可能出现兼容性问题
**缓解**: 提供详细的安装脚本和故障排除文档

**风险**: Notebook内容过于复杂，学习者难以跟上
**缓解**: 采用渐进式设计，从简单到复杂，提供充分的解释

**风险**: 进度追踪数据丢失
**缓解**: 实现自动备份和数据恢复机制